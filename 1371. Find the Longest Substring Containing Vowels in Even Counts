维护一个 当前 bitmask 状态：
每次遇到元音，就翻转对应的那一位（0→1, 1→0）。
如果某两个下标的状态相同，说明这段区间里的元音计数全是偶数 
用哈希表记录「某个状态第一次出现的位置」

class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        vowel_to_bit = {'a': 0, 'e': 1, 'i': 2, 'o': 3, 'u': 4}

        state = 0
        freq = {0: -1}  # 状态第一次出现的下标
        ans = 0

        for i, c in enumerate(s):
            if c in vowel_to_bit:
                state ^= (1 << vowel_to_bit[c])  # 翻转对应位

            if state in freq:
                ans = max(ans, i - freq[state])
            else:
                freq[state] = i

        return ans
