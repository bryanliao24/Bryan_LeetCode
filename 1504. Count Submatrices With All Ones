🔹 第一次：橫向疊（左到右）
用 left[r][c] 算出「這個格子往左連續有多少個 1」
👉 這樣就知道，如果我要一個矩形的右下角在 (r,c)，那麼它的最大寬度是多少。

🔹 第二次：縱向疊（下到上）
對每個 (r,c) 往上走，看能疊幾行：
每往上一行，更新一次 最小寬度 = min(之前的, left[k][c])
因為往上擴展時，矩形的寬度可能會被更上面的一行限制住
每疊一行，就把「這個高度下能有的矩形數」加到答案

class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        # 1) left[r][c] = 該格子向左連續 1 的長度
        left = [[0]*n for _ in range(m)]
        for r in range(m):
            run = 0
            for c in range(n):
                if mat[r][c] == 1:
                    run += 1
                else:
                    run = 0
                left[r][c] = run

        # 2) 以每個 (r,c) 為右下角，往上疊
        ans = 0
        for r in range(m):
            for c in range(n):
                if mat[r][c] == 0:
                    continue
                minW = float('inf')
                k = r
                while k >= 0 and left[k][c] > 0:
                    minW = min(minW, left[k][c])
                    ans += minW
                    k -= 1
        return ans

-------------------------------------------------------------------------------------


对每一行 r，我们把矩阵当成一张“直方图”, heights[c] 表示从当前行 r 往上连续的 1 的个数

class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        if not mat or not mat[0]:
            return 0
        m, n = len(mat), len(mat[0])
        heights = [0] * n
        ans = 0

        for r in range(m):
            # 1) 更新直方图高度
            for c in range(n):
                heights[c] = heights[c] + 1 if mat[r][c] == 1 else 0

            # 2) 用单调栈统计以每一列为右边界的子矩阵数量
            stack = []          # (height, count)
            curr_sum = 0        # 以当前列为右边界的矩形总数
            for c in range(n):
                h = heights[c]
                count = 1
                while stack and stack[-1][0] >= h:
                    prev_h, prev_cnt = stack.pop()
                    curr_sum -= (prev_h - h) * prev_cnt
                    count += prev_cnt
                stack.append((h, count))
                curr_sum += h
                ans += curr_sum

        return ans
        
