缩放单位：把 n 变成 m = ceil(n/25)，操作是减 (4,0)/(3,1)/(2,2)/(1,3)。
A、B 同时空 → 0.5
A 先空 → 1.0
B 先空 → 0.0
等概率转移：四个子状态的平均值（乘 0.25）。
第一次算到某个 (a,b)，把结果存进 dp[(a,b)]。
后面如果又遇到同一状态，直接返回缓存，不再递归。

class Solution:
    def soupServings(self, n: int) -> float:
        if n == 0:
            return 0.5  # 两锅都是 0 -> 同时空

        # 大数近似优化
        if n > 5000:
            return 1.0

        m = math.ceil(n / 25)
        dp = {}  # key: (a, b) -> value: 概率

        def f(a: int, b: int) -> float:
            if a <= 0 and b <= 0: return 0.5
            if a <= 0:            return 1.0
            if b <= 0:            return 0.0

            if (a, b) in dp:
                return dp[(a, b)]

            dp[(a, b)] = 0.25 * (
                f(a-4, b)   +
                f(a-3, b-1) +
                f(a-2, b-2) +
                f(a-1, b-3)
            )
            return dp[(a, b)]

        return f(m, m)
