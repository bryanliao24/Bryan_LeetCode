maze = [["+","+",".","+"],[".",".",".","+"],["+","+","+","."]]
entrance = [1,2]
from collections import deque 

def nearestExit(maze, entrance):
    """
    > With BFS, The first exit it comes across is the closest exit
    > Level represents number of steps ahead
    """
    m, n = len(maze), len(maze[0])
    directions = [(1,0), (0,1), (-1,0), (0,-1)]
    
    queue = deque([(*entrance, 0)])
    visited = [[False] * n for _ in range(m)]
    visited[entrance[0]][entrance[1]] = True
    print(queue)
    print(visited)
    print("-----start")
    
    while queue:
        i, j, level = queue.popleft()
        
        # Return as soon as the nearest exit is found
        # If the current position is on the edges of the grid, thats our exit.
        if (i in {0, m - 1} or j in {0, n - 1}) and [i, j] != entrance:
            # Level represents the shortest distance from the entrance
            return level     
        
        # Iterate through all the directions
        for x, y in directions:
            x, y = x + i, y + j
            # Make sure each neighbour cell is within the boundary and 
            # not yet visited and it is an empty cell
            if 0 <= x < m and 0 <= y < n and not visited[x][y] and maze[x][y] == '.':
                queue.append((x, y, level + 1))
                visited[x][y] = True

    return -1
    
    
print(nearestExit(maze, entrance))


---------------------------------------------------------------------------------------------

class Solution:
    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
        row, col = len(maze), len(maze[0])
        directions = [(1,0), (0,1), (-1,0), (0,-1)]
        min_steps = [float('inf')]  # 用列表封装，方便在递归中修改

        def dfs(x, y, steps):
            # 如果走到边界且不是入口，更新最小步数
            if (x == 0 or y == 0 or x == row -1 or y == col -1) and [x,y] != entrance:
                min_steps[0] = min(min_steps[0], steps)
                return

            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < row and 0 <= ny < col and maze[nx][ny] == '.':
                    maze[nx][ny] = '+'  # 标记已访问
                    dfs(nx, ny, steps + 1)
                    maze[nx][ny] = '.'  # 回溯，恢复状态

        # 从入口开始 DFS
        maze[entrance[0]][entrance[1]] = '+'  # 标记入口
        dfs(entrance[0], entrance[1], 0)

        return min_steps[0] if min_steps[0] != float('inf') else -1
