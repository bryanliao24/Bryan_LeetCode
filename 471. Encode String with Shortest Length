dp[i][j] 表示字符串 s[i:j+1] 的最短编码。
在每个 dp[i][j] 位置，我们要考虑两种情况：
1. 分割（Split）：尝试在中间任何 k 分割成两段，然后取 dp[i][k] + dp[k+1][j]。
2. 重复压缩（Repeat Compression）：如果 s[i:j+1] 是由某个更短的字符串重复而来，例如 "abcabcabc" 是 "abc" 的 3 次重复 → 可以压缩为 "3[abc]"
遍历的部分从单个字符的压缩方式开始，慢慢拼成 2 个字符的，3 个字符的……直到整个字符串 abc, 第一轮loop是a,b,c单个看，第二轮是ab,bc两个两个看，第三轮是abc
终点 j 是根据 i 和长度 L 算出来的。因为：L = j - i + 1 → j = i + L - 1
比如 "aaaaa"（长度5）可以压缩成 "5[a]" 
原长度：5
压缩后：len("5[a]") = 4 ✅ 所以只有大于=5才压缩
(t + t).find(t, 1) 返回的不是重复次数，而是小周期长度


class Solution:
    def encode(self, s: str) -> str:
        n = len(s)
        if n == 0:
            return ""
        dp = [[""] * n for _ in range(n)]

        for L in range(1, n + 1):
            for i in range(n - L + 1):
                j = i + L - 1
                t = s[i:j + 1]
                best = t  # 基线：不压缩

                # 尝试切分
                for k in range(i, j):
                    cand = dp[i][k] + dp[k + 1][j]
                    if len(cand) < len(best):
                        best = cand

                # 尝试重复压缩（长度>=5时才可能更短）
                if L >= 5:
                    pos = (t + t).find(t, 1)  # 最小周期
                    if 0 <= pos < L and L % pos == 0:
                        unit = dp[i][i + pos - 1]  # 单元内部也取最优
                        cand = f"{L // pos}[{unit}]"
                        if len(cand) < len(best):
                            best = cand

                dp[i][j] = best

        return dp[0][n - 1]
